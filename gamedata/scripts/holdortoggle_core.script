-- holdortoggle/core.script
-- Main coordinator - loads all modules and dispatches events

-- Load all modules
local state = holdortoggle_state
local utils = holdortoggle_utils
local config = holdortoggle_config
local stance_utils = holdortoggle_stance_utils
local movement_base = holdortoggle_movement_base
local lean = holdortoggle_features_lean
local inventory = holdortoggle_features_inventory
local pda = holdortoggle_features_pda
local pda_hands = holdortoggle_features_pda_hands
local detector = holdortoggle_features_detector
local autowalk = holdortoggle_features_autowalk
local qaw = holdortoggle_features_qaw
local vanilla_prone = holdortoggle_stance_systems_vanilla_prone
local fluid_stance = holdortoggle_stance_systems_fluid_stance
local progressive_stance = holdortoggle_stance_systems_progressive_stance

-- Initialize module cross-references
function initialize()
    -- Give config access to all modules
    config.set_modules({
        movement_base = movement_base,
        lean = lean,
        inventory = inventory,
        pda = pda,
        pda_hands = pda_hands,
        detector = detector,
        autowalk = autowalk,
        qaw = qaw,
        vanilla_prone = vanilla_prone,
        fluid_stance = fluid_stance,
        progressive_stance = progressive_stance
    })

    -- Give movement_base access to config
    movement_base.set_config_module(config)

    -- Initialize QAW integration
    qaw.initialize()
end

-- MCM load handler
function on_mcm_load()
    return config.on_mcm_load()
end

-- Option change handler
function on_option_change()
    config.on_option_change()
end

-- First update handler
function actor_on_first_update()
    utils.debug_log("[CORE] actor_on_first_update called")
    -- Sync MCM values from game settings first
    utils.debug_log("[CORE] Calling sync_from_game_settings")
    config.sync_from_game_settings()
    -- Then apply MCM settings
    utils.debug_log("[CORE] Calling on_option_change")
    on_option_change()
    utils.debug_log("[CORE] actor_on_first_update completed")
end

-- Before key press handler
function on_before_key_press(dik, bind, dis, flags)
    -- QAW (needs to block reload/alt when wheel is shown)
    if qaw.on_before_key_press(dik, bind, dis, flags) then
        return true
    end

    -- Inventory needs to block first
    if inventory.on_before_key_press(dik, bind, dis, flags) then
        return true
    end

    -- PDA (hold/release)
    if pda.on_before_key_press(dik, bind, dis, flags) then
        return true
    end

    -- Detector (weapon + detector prevention)
    if detector.on_before_key_press(dik, bind, dis, flags) then
        return true
    end

    -- Lean (for opposite lean canceling)
    if lean.on_before_key_press(dik, bind, dis, flags) then
        return true
    end

    -- Stance system (if it has on_before_key_press)
    if state.active_stance_system and state.active_stance_system.on_before_key_press then
        if state.active_stance_system.on_before_key_press(dik, bind, dis, flags) then
            return true
        end
    end

    -- Movement base
    if movement_base.on_before_key_press(dik, bind, dis, flags) then
        return true
    end

    return false
end

-- Recursion detection counter
local recursion_counter = 0
local last_recursion_key = nil

-- Key press handler
function on_key_press(key)
    -- Entry point logging with recursion detection
    recursion_counter = recursion_counter + 1

    local key_name = "UNKNOWN"
    if key == bind_to_dik(key_bindings.kCROUCH) then
        key_name = "CROUCH"
    elseif key == bind_to_dik(key_bindings.kACCEL) then
        key_name = "WALK"
    elseif key == bind_to_dik(stance_utils.get_sprint_key()) then
        key_name = "SPRINT"
    elseif key == bind_to_dik(key_bindings.kWPN_RELOAD) then
        key_name = "RELOAD"
    end

    utils.debug_log(string.format("[CORE ENTRY] key_press #%d: key=%s(%d) sprint_block_crouch=%s sprint_block_walk=%s prone_crouch=%s prone_walk=%s",
        recursion_counter, key_name, key,
        tostring(state.restoring_crouch_from_sprint_block),
        tostring(state.restoring_walk_from_sprint_block),
        tostring(state.restoring_crouch_from_prone_exit),
        tostring(state.restoring_walk_from_prone_exit)))

    -- Detect recursion loop (same key called many times in rapid succession)
    if recursion_counter > 100 then
        utils.debug_log(string.format("[CORE RECURSION DETECTED] Counter at %d, last_key=%s, current_key=%s - BLOCKING TO PREVENT HANG",
            recursion_counter, tostring(last_recursion_key), key_name))
        recursion_counter = 0
        return
    end

    last_recursion_key = key

    -- Check QAW integration first (for closing with reload/ammo keys)
    if qaw.on_key_press(key) then
        recursion_counter = recursion_counter - 1
        return  -- QAW handled it
    end

    -- Try stance system first (if active)
    if state.active_stance_system then
        if state.active_stance_system.on_key_press(key) then
            recursion_counter = recursion_counter - 1
            return  -- Stance system handled it
        end
    end

    -- Fall back to other systems
    movement_base.on_key_press(key)
    lean.on_key_press(key)
    inventory.on_key_press(key)
    pda.on_key_press(key)
    autowalk.on_key_press(key)

    recursion_counter = recursion_counter - 1
end

-- Key hold handler
function on_key_hold(key)
    -- Check QAW integration first (for modifier bypass on hold)
    if qaw.on_key_hold(key) then
        return  -- QAW handled it
    end

    -- Try stance system first (if active)
    if state.active_stance_system then
        if state.active_stance_system.on_key_hold(key) then
            return  -- Stance system handled it
        end
    end

    -- Fall back to other systems
    movement_base.on_key_hold(key)
    lean.on_key_hold(key)
    inventory.on_key_hold(key)
    pda.on_key_hold(key)
    autowalk.on_key_hold(key)
end

-- Key release handler
function on_key_release(key)
    -- Try stance system first (if active)
    if state.active_stance_system then
        if state.active_stance_system.on_key_release(key) then
            return  -- Stance system handled it
        end
    end

    -- Fall back to other systems
    movement_base.on_key_release(key)
    lean.on_key_release(key)
    inventory.on_key_release(key)
    pda.on_key_release(key)
    autowalk.on_key_release(key)
end

-- Game start handler
function on_game_start()
    initialize()

    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("on_key_press", on_key_press)
    RegisterScriptCallback("on_key_hold", on_key_hold)
    RegisterScriptCallback("on_key_release", on_key_release)
    RegisterScriptCallback("on_before_key_press", on_before_key_press)
end
