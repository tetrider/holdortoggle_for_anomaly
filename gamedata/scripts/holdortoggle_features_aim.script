-- holdortoggle/features/aim.script
-- ADS/Zoom hold/release logic

local state = holdortoggle_state
local utils = holdortoggle_utils
local stance_utils = holdortoggle_stance_utils

-- MCM options
local hot_aim = 0 -- 0=Hold, 1=Toggle, 2=Hold+Toggle
local hot_sprint = 0 -- Need to check sprint mode for reactivation logic

function update_options()
    if ui_mcm then
        hot_aim = ui_mcm.get("mcm/holdortoggle/main/hot_aim")
        hot_sprint = ui_mcm.get("mcm/holdortoggle/main/hot_sprint")
    end
end

function on_before_key_press(dik, bind, dis, flags)
    -- No blocking logic needed for ADS
    return false
end

function on_key_press(key)
    -- Track aim press for Hold mode (0)
    -- For Hold mode, immediately mark as holding to mimic hold behavior
    if (key == bind_to_dik(key_bindings.kWPN_ZOOM)) then
        if hot_aim == 0 then
            state.holding_aim = true
            state.aim_key_down = true
            utils.debug_log("[AIM] on_key_press: Hold mode - marking as holding")
        elseif hot_aim == 2 then
            state.aim_key_down = true
            utils.debug_log("[AIM] on_key_press: Hold+Toggle mode - key down")
        end
    end
end

function on_key_hold(key)
    local is_modifier = utils.is_modifier_key(key)

    -- Aim hold
    -- For Hold+Toggle mode (2), track when key passes hold threshold
    if (key == bind_to_dik(key_bindings.kWPN_ZOOM)) and ui_mcm.key_hold("holdortoggle", key) then
        -- Only set holding for Hold+Toggle mode (2)
        -- Hold mode (0) already set it in on_key_press
        if hot_aim == 2 then
            state.holding_aim = true
            utils.debug_log("[AIM] on_key_hold: Hold+Toggle mode - threshold passed, marking as holding")
        end
        if is_modifier then return end
    end
end

function on_key_release(key)
    if (key == bind_to_dik(key_bindings.kWPN_ZOOM)) then
        utils.debug_log("[AIM] on_key_release: aim key released, holding_aim=" .. tostring(state.holding_aim) .. ", weapon_is_zoomed=" .. tostring(axr_main.weapon_is_zoomed))

        local aim_was_held = state.holding_aim

        -- Handle release based on mode
        if hot_aim == 0 then
            -- Hold mode: always deactivate if aiming
            if state.holding_aim and axr_main.weapon_is_zoomed then
                utils.debug_log("[AIM] on_key_release: Hold mode - toggling off")
                level.press_action(bind_to_dik(key_bindings.kWPN_ZOOM))
            end
        elseif hot_aim == 2 then
            -- Hold+Toggle mode: only deactivate if held past threshold
            if state.holding_aim and axr_main.weapon_is_zoomed then
                utils.debug_log("[AIM] on_key_release: Hold+Toggle mode - was held, toggling off")
                level.press_action(bind_to_dik(key_bindings.kWPN_ZOOM))
            end
            -- If tapped (holding_aim is false), game handles toggle normally
        end

        -- Reset states
        state.holding_aim = false
        state.aim_key_down = false

        -- Reactivate sprint if player is still holding sprint key
        -- Only if both aim and sprint are in Hold or Hold+Toggle mode
        if aim_was_held and (hot_aim == 0 or hot_aim == 2) and (hot_sprint == 0 or hot_sprint == 2) then
            if (state.holding_sprint or state.sprint_key_down) and not IsMoveState("mcSprint") and IsMoveState("mcFwd") then
                utils.debug_log("[AIM] on_key_release: Reactivating sprint after aim release")
                CreateTimeEvent("holdortoggle_aim", "reactivate_sprint_after_aim", 0.05, function()
                    if (state.holding_sprint or state.sprint_key_down) and not IsMoveState("mcSprint") and IsMoveState("mcFwd") then
                        utils.debug_log("[AIM] Reactivating sprint now")
                        level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                    end
                    return true
                end)
            end
        end
    end
end
