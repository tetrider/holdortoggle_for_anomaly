-- holdortoggle/features/pda.script
-- PDA hold/release logic (tap to toggle, hold to temporary open)

local state = holdortoggle_state
local utils = holdortoggle_utils

-- MCM options
-- pda_mode: 0=Default, 1=On Release, 2=Hold to Zoom, 3=On Release + Zoom
local pda_mode = 0
local restore_hands_after_pda = false

-- Helper functions to check mode
local function is_on_release_mode()
    return pda_mode == 1 or pda_mode == 3
end

local function is_hold_to_zoom_mode()
    return pda_mode == 2
end

local function is_on_release_zoom_mode()
    return pda_mode == 3
end

local function is_pda_feature_enabled()
    return pda_mode > 0
end

function update_options()
    if ui_mcm then
        pda_mode = ui_mcm.get("mcm/holdortoggle/qol/pda_mode") or 0
        restore_hands_after_pda = ui_mcm.get("mcm/holdortoggle/qol/restore_hands_after_pda")
    end
end

-- Helper function: Open PDA, simulate reload, then click for zoom
local function start_pda_zoom_sequence(context_label)
    -- Open PDA based on mode
    local pda_menu = ActorMenu.get_pda_menu()
    local pda3d = get_console_cmd(1, "g_3d_pda")
    if pda3d then
        db.actor:activate_slot(8)
    else
        pda_menu:ShowDialog(true)
        pda_menu:SetActiveSubdialog("eptTasks")
    end

    -- Simulate reload 5 times
    local frames_sent = 0
    CreateTimeEvent("pda_zoom_events", "simulate_reload_" .. context_label, 0, function()
        frames_sent = frames_sent + 1
        utils.debug_log("[PDA_ZOOM] " .. context_label .. " - simulating reload (frame " .. frames_sent .. "/5)")

        local reload_dik = bind_to_dik(key_bindings.kWPN_RELOAD)
        level.press_action(reload_dik)
        level.release_action(reload_dik)

        if frames_sent >= 5 then
            utils.debug_log("[PDA_ZOOM] " .. context_label .. " - completed 5 reload attempts")
            return true  -- Done
        end
        return false  -- Continue for next frame
    end)

    -- After 0.05 seconds, simulate left mouse click (retry up to 5 times if camera mode is active)
    local click_attempts = 0
    CreateTimeEvent("pda_zoom_events", "simulate_click_" .. context_label, 0.5, function()
        click_attempts = click_attempts + 1
        if game.only_movekeys_allowed() then
            if click_attempts >= 5 then
                utils.debug_log("[PDA_ZOOM] " .. context_label .. " - gave up after 5 attempts, camera control mode still active")
                return true  -- Done, give up
            end
            utils.debug_log("[PDA_ZOOM] " .. context_label .. " - camera control mode active, retrying (attempt " .. click_attempts .. "/5)")
            return false  -- Retry
        else
            utils.debug_log("[PDA_ZOOM] " .. context_label .. " - simulating left click after 0.05s (attempt " .. click_attempts .. ")")
            level.press_action(DIK_keys.MOUSE_1)
            level.release_action(DIK_keys.MOUSE_1)
            return true  -- Done
        end
    end)
end


function on_before_key_press(dik, bind, dis, flags)
    -- Block default PDA action when any PDA mode is enabled
    -- DON'T block if flags.ret_value is already false (another mod already blocked it, like keywrapper)
    if bind == key_bindings.kACTIVE_JOBS and is_pda_feature_enabled() then
        if flags.ret_value ~= false then
            utils.debug_log("[HOT_PDA] on_before_key_press: blocking and tracking, dik=" .. tostring(dik) .. ", flags.ret_value=" .. tostring(flags.ret_value))
            -- Block the default PDA action
            flags.ret_value = false
        else
            utils.debug_log("[HOT_PDA] on_before_key_press: key already blocked by another mod (keywrapper?), tracking only")
        end
        -- Set pdaing flag here since on_key_press won't be called when we block
        state.pdaing = true
        if state.holding_pda then
            state.holding_pda = false
        end

        -- Hold to Zoom mode: Save state but DON'T open PDA yet (wait for hold or release)
        if is_hold_to_zoom_mode() and db.actor:item_in_slot(8) then
            local pda_menu = ActorMenu.get_pda_menu()
            local pda3d = get_console_cmd(1, "g_3d_pda")
            local is_pda_open = pda_menu:IsShown() or (pda3d and db.actor:active_slot() == 8)

            -- Save PDA state BEFORE we potentially open it
            state.pda_was_open_before_press = is_pda_open

            if not is_pda_open then
                -- Save what slot was active before opening (for animation timing)
                state.pda_slot_before_open = db.actor:active_slot()
                utils.debug_log("[PDA_ZOOM] PDA key pressed from slot " .. tostring(state.pda_slot_before_open) .. " - waiting for hold or release")

                -- DON'T open PDA yet - wait for hold detection or key release
            end
        end
    end
end

function on_key_press(key)
    -- Detect Escape key closing PDA (for hand restoration)
    if key == DIK_keys.DIK_ESCAPE then
        local pda_menu = ActorMenu.get_pda_menu()
        local pda3d = get_console_cmd(1, "g_3d_pda")
        local is_pda_open = pda_menu:IsShown() or (pda3d and db.actor:active_slot() == 8)

        if is_pda_open and restore_hands_after_pda then
            utils.debug_log("[HOT_PDA] Escape pressed while PDA open - triggering hand restoration")
            -- Use TimeEvent to call on_pda_close after PDA actually closes
            CreateTimeEvent("pda_events", "escape_close_restore", 0, function()
                if holdortoggle_features_pda_hands and holdortoggle_features_pda_hands.on_pda_close then
                    holdortoggle_features_pda_hands.on_pda_close()
                end
                return true
            end)
        end
    end

    -- PDA key press
    -- NOTE: This won't be called when any PDA mode is enabled
    -- because on_before_key_press blocks the key press
    if (key == bind_to_dik(key_bindings.kACTIVE_JOBS)) then
        utils.debug_log("[HOT_PDA] on_key_press: PDA key pressed (shouldn't happen if feature is enabled)")
    end
end

function on_key_hold(key)
    -- PDA key hold
    if (key == bind_to_dik(key_bindings.kACTIVE_JOBS)) then
        local holds = ui_mcm.key_hold("holdortoggle", key)
        utils.debug_log("[HOT_PDA] on_key_hold called: pda_mode=" .. tostring(pda_mode) .. ", holds=" .. tostring(holds))

        -- Check Hold to Zoom mode FIRST (higher priority)
        if holds and is_hold_to_zoom_mode() then
            if db.actor:item_in_slot(8) then  -- Verify PDA exists
                -- Don't activate zoom if PDA was already open before pressing the key
                if state.pda_was_open_before_press then
                    utils.debug_log("[PDA_ZOOM] PDA already open - ignoring zoom activation")
                    return
                end

                -- Set flag immediately when hold detected (even if PDA not fully open yet)
                state.pda_zoom_opening = true
                utils.debug_log("[PDA_ZOOM] Hold detected, starting zoom sequence from slot " .. tostring(state.pda_slot_before_open))

                -- Check if detector is active (interferes with PDA zoom)
                local detector_active = db.actor:active_detector() ~= nil

                -- Empty hands: trigger reload immediately (before PDA fully opens)
                -- Weapon/Detector: switch to empty hands first
                local is_empty_hands = (state.pda_slot_before_open == 0) and not detector_active

                if is_empty_hands then
                    -- Empty hands: Open PDA NOW (on hold detection), then start zoom sequence
                    utils.debug_log("[PDA_ZOOM] Empty hands - hold detected, opening PDA now")

                    -- Save equipment state (if restore_hands enabled)
                    if holdortoggle_features_pda_hands and holdortoggle_features_pda_hands.on_pda_open then
                        holdortoggle_features_pda_hands.on_pda_open()
                    end

                    -- Start the zoom sequence
                    start_pda_zoom_sequence("Empty hands")
                    return  -- Exit after creating TimeEvents
                end

                -- Weapon/Detector: Switch to empty hands first, then use empty hands logic
                -- This avoids weapon deactivation and detector interference timing issues
                if not is_empty_hands then
                    local item_type = detector_active and "Detector" or "Weapon"
                    utils.debug_log("[PDA_ZOOM] " .. item_type .. " - hold detected from slot " .. tostring(state.pda_slot_before_open) .. ", switching to empty hands first")

                    -- Save equipment state (if restore_hands enabled)
                    if holdortoggle_features_pda_hands and holdortoggle_features_pda_hands.on_pda_open then
                        holdortoggle_features_pda_hands.on_pda_open()
                    end

                    -- If detector is active, simulate detector key to deactivate it
                    if detector_active then
                        local detector_dik = bind_to_dik(key_bindings.kDETECTOR)
                        level.press_action(detector_dik)
                        level.release_action(detector_dik)
                        utils.debug_log("[PDA_ZOOM] Detector - simulated detector key to deactivate")
                    end

                    -- Switch to empty hands (for weapons, or to ensure detector is fully cleared)
                    db.actor:activate_slot(NO_ACTIVE_SLOT)

                    -- Wait for slot to change to 0 (empty hands) AND detector to deactivate, then open PDA and simulate reload
                    local attempt = 0
                    CreateTimeEvent("pda_zoom_events", "switch_to_empty_then_pda", 0, function()
                        attempt = attempt + 1
                        local current_slot = db.actor:active_slot()
                        local detector_still_active = db.actor:active_detector() ~= nil

                        if current_slot == 0 and not detector_still_active then
                            -- Now at empty hands with no detector, start zoom sequence
                            utils.debug_log("[PDA_ZOOM] " .. item_type .. " - now at empty hands (detector deactivated), starting zoom sequence")
                            start_pda_zoom_sequence(item_type .. " (via empty hands)")
                            return true  -- Done switching
                        elseif attempt > 300 then
                            utils.debug_log("[PDA_ZOOM] " .. item_type .. " - timeout waiting for empty hands (current=" .. tostring(current_slot) .. ")")
                            return true
                        end

                        return false  -- Keep waiting for slot 0
                    end)
                    return  -- Exit after creating TimeEvent for weapon
                end
            else
                utils.debug_log("[PDA_ZOOM] No PDA in slot 8")
            end
            return  -- Handled by Hold to Zoom mode
        end

        -- Then check On Release mode (if Hold to Zoom didn't handle it)
        if holds and is_on_release_mode() then
            utils.debug_log("[HOT_PDA] on_key_hold: PDA key held")
            state.holding_pda = true
        end
    end
end

function on_key_release(key)
    -- PDA key release
    if (key == bind_to_dik(key_bindings.kACTIVE_JOBS)) then
        -- Track if we were in zoom opening mode
        local was_zoom_opening = state.pda_zoom_opening

        -- Clear pda_zoom_opening flag if it was set
        if state.pda_zoom_opening then
            utils.debug_log("[PDA_ZOOM] Key released, clearing pda_zoom_opening flag")
            state.pda_zoom_opening = false
        end

        -- Skip release logic if no PDA mode is enabled
        if not is_pda_feature_enabled() then
            return
        end

        utils.debug_log("[HOT_PDA] on_key_release: PDA key released, holding_pda=" .. tostring(state.holding_pda) .. ", pdaing=" .. tostring(state.pdaing) .. ", was_zoom_opening=" .. tostring(was_zoom_opening))

        -- Hold to Zoom mode: Only close PDA on tap if it's currently open
        -- Don't close if hold-to-zoom was triggered (just zoomed, don't close)
        if is_hold_to_zoom_mode() and not was_zoom_opening and not state.holding_pda and state.pdaing then
            local pda_menu = ActorMenu.get_pda_menu()
            local pda3d = get_console_cmd(1, "g_3d_pda")
            local is_pda_open = pda_menu:IsShown() or (pda3d and db.actor:active_slot() == 8)

            -- If PDA was ALREADY open before this press: close it
            if is_pda_open and state.pda_was_open_before_press then
                -- Tap to close PDA
                utils.debug_log("[PDA_ZOOM] Tap on open PDA - closing")

                -- Notify pda_hands feature that PDA is closing (if it's loaded)
                if holdortoggle_features_pda_hands and holdortoggle_features_pda_hands.on_pda_close then
                    holdortoggle_features_pda_hands.on_pda_close()
                end

                -- Hide PDA dialog if in 2D mode
                if not pda3d then
                    pda_menu:HideDialog()
                else
                    -- For 3D PDA, switch away from slot 8
                    -- Only close if pda_hands is not handling restoration
                    if not restore_hands_after_pda then
                        db.actor:activate_slot(NO_ACTIVE_SLOT)
                    end
                end
            -- If PDA was NOT open before: open it (tap without hold)
            elseif not is_pda_open and not state.pda_was_open_before_press and db.actor:item_in_slot(8) then
                -- Tap to open PDA (no zoom)
                utils.debug_log("[PDA_ZOOM] Tap to open PDA (no zoom)")

                -- Notify pda_hands feature that PDA is opening (if it's loaded)
                if holdortoggle_features_pda_hands and holdortoggle_features_pda_hands.on_pda_open then
                    holdortoggle_features_pda_hands.on_pda_open()
                end

                -- Open PDA based on mode
                if pda3d then
                    db.actor:activate_slot(8)
                else
                    pda_menu:ShowDialog(true)
                    pda_menu:SetActiveSubdialog("eptTasks")
                end
            end
        -- On Release mode: original toggle behavior
        elseif is_on_release_mode() and not state.holding_pda and not was_zoom_opening and state.pdaing then
            local pda_menu = ActorMenu.get_pda_menu()
            local pda3d = get_console_cmd(1, "g_3d_pda")

            -- Check if PDA is shown
            if pda_menu:IsShown() or (pda3d and db.actor:active_slot() == 8) then
                utils.debug_log("[HOT_PDA] Closing PDA! pda3d=" .. tostring(pda3d) .. ", pda_menu:IsShown()=" .. tostring(pda_menu:IsShown()) .. ", current_slot=" .. tostring(db.actor:active_slot()))

                -- Notify pda_hands feature that PDA is closing (if it's loaded)
                if holdortoggle_features_pda_hands and holdortoggle_features_pda_hands.on_pda_close then
                    holdortoggle_features_pda_hands.on_pda_close()
                end

                -- Hide PDA dialog if in 2D mode
                if not pda3d then
                    utils.debug_log("[HOT_PDA] Calling pda_menu:HideDialog() for 2D PDA")
                    pda_menu:HideDialog()
                    utils.debug_log("[HOT_PDA] After HideDialog(), pda_menu:IsShown()=" .. tostring(pda_menu:IsShown()))
                else
                    utils.debug_log("[HOT_PDA] 3D PDA mode - closing PDA")
                    -- For 3D PDA, switch away from slot 8
                    -- Only close if pda_hands is not handling restoration
                    if not restore_hands_after_pda then
                        utils.debug_log("[HOT_PDA] Switching to NO_ACTIVE_SLOT (restore_hands_after_pda disabled)")
                        db.actor:activate_slot(NO_ACTIVE_SLOT)
                    else
                        utils.debug_log("[HOT_PDA] Skipping slot switch - pda_hands will handle restoration")
                    end
                end
            -- Open PDA if player has one in slot 8
            elseif db.actor:item_in_slot(8) then
                -- Notify pda_hands feature that PDA is opening (if it's loaded)
                if holdortoggle_features_pda_hands and holdortoggle_features_pda_hands.on_pda_open then
                    holdortoggle_features_pda_hands.on_pda_open()
                end

                -- Mode 3: On Release + Zoom - open with zoom sequence
                if is_on_release_zoom_mode() then
                    utils.debug_log("[HOT_PDA] Opening PDA with zoom (On Release + Zoom mode)!")

                    -- Save slot for zoom sequence
                    state.pda_slot_before_open = db.actor:active_slot()

                    -- Check if detector is active (interferes with PDA zoom)
                    local detector_active = db.actor:active_detector() ~= nil
                    local is_empty_hands = (state.pda_slot_before_open == 0) and not detector_active

                    if is_empty_hands then
                        -- Empty hands: start zoom sequence directly
                        start_pda_zoom_sequence("On Release + Zoom (empty hands)")
                    else
                        -- Weapon/Detector: Switch to empty hands first
                        local item_type = detector_active and "Detector" or "Weapon"

                        -- If detector is active, simulate detector key to deactivate it
                        if detector_active then
                            local detector_dik = bind_to_dik(key_bindings.kDETECTOR)
                            level.press_action(detector_dik)
                            level.release_action(detector_dik)
                        end

                        -- Switch to empty hands
                        db.actor:activate_slot(NO_ACTIVE_SLOT)

                        -- Wait for empty hands, then start zoom sequence
                        local attempt = 0
                        CreateTimeEvent("pda_zoom_events", "on_release_zoom_switch", 0, function()
                            attempt = attempt + 1
                            local current_slot = db.actor:active_slot()
                            local detector_still_active = db.actor:active_detector() ~= nil

                            if current_slot == 0 and not detector_still_active then
                                start_pda_zoom_sequence("On Release + Zoom (" .. item_type .. ")")
                                return true
                            elseif attempt > 300 then
                                return true  -- Timeout
                            end
                            return false
                        end)
                    end
                else
                    -- Mode 1: On Release - simple open without zoom
                    utils.debug_log("[HOT_PDA] Opening PDA!")

                    local pda3d = get_console_cmd(1, "g_3d_pda")
                    if pda3d then
                        db.actor:activate_slot(8)
                    else
                        local pda_menu = ActorMenu.get_pda_menu()
                        pda_menu:ShowDialog(true)
                        pda_menu:SetActiveSubdialog("eptTasks")
                    end
                end
            end
        end
        state.holding_pda = false
        state.pdaing = false
    end
end
