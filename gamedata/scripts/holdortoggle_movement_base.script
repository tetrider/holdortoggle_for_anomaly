-- holdortoggle/movement_base.script
-- Basic movement (crouch, walk, sprint) when no stance system is active

local state = holdortoggle_state
local utils = holdortoggle_utils
local stance_utils = holdortoggle_stance_utils
local config = nil  -- Will be set by core

-- MCM options
local hot_crouch = 0 -- 0=Hold, 1=Toggle, 2=Hold+Toggle
local hot_walk = 0 -- 0=Hold, 1=Toggle, 2=Hold+Toggle
local hot_sprint = 0 -- 0=Hold, 1=Toggle, 2=Hold+Toggle
local hot_sprint_cancel = false

-- Track if last sprint press was blocked
local sprint_key_was_blocked = false

-- Track if restoration TimeEvent is currently active
local restoration_active = false

function set_config_module(cfg)
    config = cfg
end

function update_options()
    if ui_mcm then
        hot_crouch = ui_mcm.get("mcm/holdortoggle/main/hot_crouch")
        hot_walk = ui_mcm.get("mcm/holdortoggle/main/hot_walk")
        hot_sprint = ui_mcm.get("mcm/holdortoggle/main/hot_sprint")
        hot_sprint_cancel = ui_mcm.get("mcm/holdortoggle/qol/hot_sprint_cancel")
    end
end

-- OPTIMIZATION NOTES:
-- 1. Early exit: ~95% reduction in per-frame overhead (most frames do no work)
-- 2. Sprint restoration: Moved from per-frame polling to one-time TimeEvent
-- 3. IsMoveState caching: Reduced redundant engine calls
function actor_on_update()
    -- Early exit when no sprint work needed (99% of frames)
    if not ((hot_sprint == 0 or hot_sprint == 2) and
            (state.holding_sprint or state.sprint_key_down) and
            (state.moving or state.autowalking)) then
        return
    end

    -- Sprint activation for Hold (0) and Hold+Toggle (2) modes
    if (hot_sprint == 0 or hot_sprint == 2) and
       (state.holding_sprint or state.sprint_key_down) and
       (state.moving or state.autowalking) then

        local is_sprinting = IsMoveState("mcSprint")
        local is_moving_fwd = IsMoveState("mcFwd")

        if not is_sprinting then
            -- Don't activate sprint if it would be blocked (prevents state flickering)
            local would_be_blocked = hot_sprint_cancel and not is_moving_fwd

            if hot_sprint == 0 and not would_be_blocked then
                level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                utils.debug_log("[MOVEMENT_BASE] actor_on_update: activating sprint (Hold mode)")
            elseif not would_be_blocked and (sprint_key_was_blocked or (hot_sprint_cancel and not is_moving_fwd)) then
                level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                utils.debug_log("[MOVEMENT_BASE] actor_on_update: activating sprint (Hold+Toggle, key was/is blocked)")
            end
        end
    end
end

function on_before_key_press(dik, bind, dis, flags)
    if bind == stance_utils.get_sprint_key() then
        -- For Hold mode (0): Set holding state immediately (actor_on_update controls activation)
        -- For Hold+Toggle mode (2): Set sprint_key_down to track press (holding_sprint set later in on_key_hold)
        if hot_sprint == 0 then
            state.holding_sprint = true
            utils.debug_log("[MOVEMENT_BASE] on_before_key_press: tracking sprint hold (Hold mode)")
        elseif hot_sprint == 2 then
            state.sprint_key_down = true
            utils.debug_log("[MOVEMENT_BASE] on_before_key_press: tracking sprint press (Hold+Toggle mode)")
        end

        -- Block sprint if hot_sprint_cancel is enabled AND not moving forward
        -- This prevents the game from entering sprint mode (which auto-cancels actions)
        local is_moving_fwd = IsMoveState("mcFwd")
        utils.debug_log("[MOVEMENT_BASE] on_before_key_press: sprint block check - hot_sprint_cancel=" .. tostring(hot_sprint_cancel) .. ", is_moving_fwd=" .. tostring(is_moving_fwd) .. ", sprint_key_was_blocked=" .. tostring(sprint_key_was_blocked))

        if hot_sprint_cancel and not is_moving_fwd then
            utils.debug_log("[MOVEMENT_BASE] on_before_key_press: blocking sprint (hot_sprint_cancel enabled, not moving forward)")

            -- Set flag to indicate sprint is blocked
            sprint_key_was_blocked = true

            -- CRITICAL FIX: The game engine auto-cancels crouch and walk when sprint is pressed,
            -- even AFTER our blocking code runs. Capture current states for restoration via TimeEvent.
            local captured_crouch = IsMoveState("mcCrouch")
            local captured_walk = IsMoveState("mcAccel")

            utils.debug_log("[MOVEMENT_BASE] on_before_key_press: captured states - crouch=" .. tostring(captured_crouch) .. ", walk=" .. tostring(captured_walk))

            -- ALWAYS create TimeEvent to restore states, even on repeated presses
            -- The game engine cancels crouch/walk on EVERY blocked press, not just the first
            if captured_crouch or captured_walk then
                -- Don't create a new TimeEvent if one is already running
                -- This prevents race conditions when double-tapping sprint
                if restoration_active then
                    utils.debug_log("[MOVEMENT_BASE] on_before_key_press: restoration already active, skipping new TimeEvent")

                    -- CRITICAL: Re-set flags if they were cleared by a previous restoration
                    -- This prevents prone exit when spamming sprint with overlapping restorations
                    if captured_crouch and not state.restoring_crouch_from_sprint_block then
                        state.restoring_crouch_from_sprint_block = true
                        utils.debug_log("[SPRINT DEBUG] Re-set restoring_crouch flag (restoration overlap)")
                    end
                    if captured_walk and not state.restoring_walk_from_sprint_block then
                        state.restoring_walk_from_sprint_block = true
                        utils.debug_log("[SPRINT DEBUG] Re-set restoring_walk flag (restoration overlap)")
                    end

                    -- CRITICAL: Remove any pending flag clear timer
                    -- The active restoration will schedule its own timer when it completes
                    -- This prevents the timer from firing before the restoration finishes
                    RemoveTimeEvent("holdortoggle", "clear_restoration_flags")
                    utils.debug_log("[SPRINT DEBUG] Removed pending flag clear timer (restoration active)")
                else
                    restoration_active = true

                    -- CRITICAL: Remove any pending flag clear timer from previous restorations
                    -- This prevents old timers from clearing the flags we're about to set
                    RemoveTimeEvent("holdortoggle", "clear_restoration_flags")

                    -- CRITICAL: Set flags IMMEDIATELY before starting restoration
                    -- This ensures progressive stance can detect and skip the restoration
                    if captured_crouch then
                        state.restoring_crouch_from_sprint_block = true
                        utils.debug_log("[SPRINT DEBUG] Set restoring_crouch flag immediately")
                    end
                    if captured_walk then
                        state.restoring_walk_from_sprint_block = true
                        utils.debug_log("[SPRINT DEBUG] Set restoring_walk flag immediately")
                    end

                    local block_time = time_global()
                    local repeat_count = 0
                    local MAX_REPEATS = 10  -- Safety limit (10 frames = ~167ms at 60fps)

                    CreateTimeEvent("holdortoggle", "restore_sprint_block_states", 0, function()
                        repeat_count = repeat_count + 1

                        -- Safety check: stop after max repeats
                        if repeat_count > MAX_REPEATS then
                            utils.debug_log("[SPRINT DEBUG] Max repeats reached after " .. (time_global() - block_time) .. "ms, stopping")
                            restoration_active = false
                            -- Clear flags on failure
                            state.restoring_crouch_from_sprint_block = false
                            state.restoring_walk_from_sprint_block = false
                            return true  -- Stop
                        end

                        -- Check if user started moving forward
                        if IsMoveState("mcFwd") then
                            utils.debug_log("[SPRINT DEBUG] Moving forward, skipping restoration")
                            restoration_active = false
                            -- Clear flags when skipping
                            state.restoring_crouch_from_sprint_block = false
                            state.restoring_walk_from_sprint_block = false
                            return true  -- Stop
                        end

                        local is_crouching = IsMoveState("mcCrouch")
                        local is_walking = IsMoveState("mcAccel")

                        -- Wait for engine to cancel the states before restoring
                        if (captured_crouch and is_crouching) or (captured_walk and is_walking) then
                            utils.debug_log("[SPRINT DEBUG] States still active, waiting... (frame " .. repeat_count .. ")")
                            return false  -- Repeat on next frame
                        end

                        -- States have been canceled by engine, now restore them
                        utils.debug_log("[SPRINT DEBUG] RESTORE after " .. (time_global() - block_time) .. "ms (" .. repeat_count .. " frames)")

                        -- CRITICAL: When prone (both states need restoration), restore walk FIRST, then crouch
                        -- This prevents progressive stance from interpreting crouch press as "exit prone"
                        if captured_walk and not is_walking then
                            utils.debug_log("[SPRINT DEBUG] RESTORING WALK")
                            level.press_action(bind_to_dik(key_bindings.kACCEL))
                        end

                        if captured_crouch and not is_crouching then
                            utils.debug_log("[SPRINT DEBUG] RESTORING CROUCH")
                            level.press_action(bind_to_dik(key_bindings.kCROUCH))
                        end

                        -- Keep flags true for 0.1s to prevent progressive stance's TimeEvents from interfering
                        -- Progressive stance has TimeEvents at 0.01s and 0.05s that need to see these flags
                        CreateTimeEvent("holdortoggle", "clear_restoration_flags", 0.1, function()
                            state.restoring_crouch_from_sprint_block = false
                            state.restoring_walk_from_sprint_block = false
                            utils.debug_log("[SPRINT DEBUG] Cleared restoration flags")
                            return true
                        end)

                        restoration_active = false
                        return true  -- Stop
                    end)
                end
            end

            return true  -- Always block the key when condition is true
        end

        -- For Toggle and Hold+Toggle modes, let the key through normally
        -- Action canceling is handled in on_key_press based on hot_sprint_cancel
    end
end

function on_key_press(key)
    -- Sprint cancels lean, aim, and prone toggles
    if (key == bind_to_dik(stance_utils.get_sprint_key())) then
        -- Only cancel actions if hot_sprint_cancel is disabled OR player is moving forward
        if not hot_sprint_cancel or IsMoveState("mcFwd") then
            if not (state.holding_lean_left or state.holding_lean_right) then
                if IsMoveState("mcLLookout") then level.press_action(bind_to_dik(key_bindings.kL_LOOKOUT)) end
                if IsMoveState("mcRLookout") then level.press_action(bind_to_dik(key_bindings.kR_LOOKOUT)) end
            end

            -- Cancel aim/zoom only if aim toggle is ON (in hold mode, releasing aim cancels it anyway)
            if axr_main.weapon_is_zoomed then
                utils.debug_log("[MOVEMENT_BASE] on_key_press: weapon_is_zoomed=true, is_aiming_toggled=" .. tostring(state.is_aiming_toggled))
                if state.is_aiming_toggled then
                    level.press_action(bind_to_dik(key_bindings.kWPN_ZOOM))
                    utils.debug_log("[MOVEMENT_BASE] on_key_press: canceling aim (toggle mode)")
                else
                    utils.debug_log("[MOVEMENT_BASE] on_key_press: NOT canceling aim (hold mode)")
                end
            end
        end
    end

    -- Track crouch press for Hold mode (only if no stance system is handling it)
    if (key == bind_to_dik(key_bindings.kCROUCH)) then
        if not state.active_stance_system or not state.active_stance_system.is_handling_crouch() then
            -- For Hold mode (0), immediately mark as holding to mimic hold behavior
            if hot_crouch == 0 then
                state.holding_crouch = true
            end
        end
    end

    -- Track walk press for Hold mode (only if no stance system is handling it)
    if (key == bind_to_dik(key_bindings.kACCEL)) then
        if not state.active_stance_system or not state.active_stance_system.is_handling_walk() then
            -- For Hold mode (0), immediately mark as holding to mimic hold behavior
            if hot_walk == 0 then
                state.holding_walk = true
            end
        end
    end

    -- Sprint Hold mode (0) tracking is handled in on_before_key_press
    -- This allows tracking even when sprint is blocked by hot_sprint_cancel

    -- Dirty move check
    if (key == bind_to_dik(key_bindings.kFWD)) or (key == bind_to_dik(key_bindings.kBACK)) then
        state.moving = true
    end
end

function on_key_hold(key)
    local is_modifier = utils.is_modifier_key(key)

    -- Crouch hold (only if no stance system is handling it)
    -- For Hold+Toggle mode (2), track when key passes hold threshold
    if (key == bind_to_dik(key_bindings.kCROUCH)) and ui_mcm.key_hold("holdortoggle", key) and IsMoveState("mcCrouch") then
        if not state.active_stance_system or not state.active_stance_system.is_handling_crouch() then
            -- Only set holding for Hold+Toggle mode (2)
            -- Hold mode (0) already set it in on_key_press
            if hot_crouch == 2 then
                state.holding_crouch = true
            end
            if is_modifier then return end
        end
    -- Walk hold (only if no stance system is handling it)
    -- For Hold+Toggle mode (2), track when key passes hold threshold
    elseif (key == bind_to_dik(key_bindings.kACCEL)) and ui_mcm.key_hold("holdortoggle", key) and IsMoveState("mcAccel") then
        if not state.active_stance_system or not state.active_stance_system.is_handling_walk() then
            -- Only set holding for Hold+Toggle mode (2)
            -- Hold mode (0) already set it in on_key_press
            if hot_walk == 2 then
                state.holding_walk = true
            end
            if is_modifier then return end
        end
    -- Sprint hold
    -- For Hold+Toggle mode (2), track when key passes hold threshold
    elseif (key == bind_to_dik(stance_utils.get_sprint_key())) and ui_mcm.key_hold("holdortoggle", key) and IsMoveState("mcSprint") then
        -- For Hold+Toggle mode (2): Mark as holding after threshold (distinguishes hold from tap)
        -- Hold mode (0) already set it in on_before_key_press
        if hot_sprint == 2 then
            state.holding_sprint = true
            utils.debug_log("[MOVEMENT_BASE] on_key_hold: sprint held past threshold (Hold+Toggle mode)")
        end
        if is_modifier then return end
    end
end

function on_key_release(key)
    -- Crouch release (only if no stance system is handling it)
    if (key == bind_to_dik(key_bindings.kCROUCH)) and state.holding_crouch then
        if not state.active_stance_system or not state.active_stance_system.is_handling_crouch() then
            if IsMoveState("mcCrouch") then
                level.press_action(bind_to_dik(key_bindings.kCROUCH))
            end
            state.holding_crouch = false
            utils.holdfix()
        end
    -- Walk release (only if no stance system is handling it)
    elseif (key == bind_to_dik(key_bindings.kACCEL)) and state.holding_walk then
        if not state.active_stance_system or not state.active_stance_system.is_handling_walk() then
            if IsMoveState("mcAccel") then
                level.press_action(bind_to_dik(key_bindings.kACCEL))
            end
            state.holding_walk = false
            utils.holdfix()
        end
    -- Sprint release
    elseif (key == bind_to_dik(stance_utils.get_sprint_key())) then
        utils.debug_log("[MOVEMENT_BASE] on_key_release: sprint released - hot_sprint=" .. tostring(hot_sprint) .. ", holding_sprint=" .. tostring(state.holding_sprint) .. ", sprint_key_was_blocked=" .. tostring(sprint_key_was_blocked))

        if hot_sprint == 0 then
            -- Hold mode: always deactivate if sprinting
            if state.holding_sprint and IsMoveState("mcSprint") then
                level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                utils.debug_log("[MOVEMENT_BASE] on_key_release: deactivating sprint (Hold mode)")
            end
        elseif hot_sprint == 2 then
            -- Hold+Toggle mode:
            -- - If held (holding_sprint is true): always deactivate
            -- - If tapped (holding_sprint is false) while sprinting AND key was blocked: toggle off
            if state.holding_sprint then
                -- Was held past threshold, deactivate
                if IsMoveState("mcSprint") then
                    level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                    utils.debug_log("[MOVEMENT_BASE] on_key_release: deactivating sprint (held)")
                end
            elseif state.sprint_key_down and sprint_key_was_blocked and IsMoveState("mcSprint") then
                -- Was tapped while sprinting AND key was blocked (didn't reach game), manually toggle off
                level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                utils.debug_log("[MOVEMENT_BASE] on_key_release: toggling sprint off (tapped, was blocked)")
            end
            -- else: tapped and key wasn't blocked, game already handled toggle
        end
        state.holding_sprint = false
        state.sprint_key_down = false

        -- Only call holdfix if sprint wasn't blocked (optional optimization)
        if not sprint_key_was_blocked then
            utils.holdfix()
        end

        -- Only reset blocked flag if blocking condition is no longer true
        -- This prevents creating multiple TimeEvents when rapidly tapping sprint while stationary
        local should_keep_blocking = hot_sprint_cancel and not IsMoveState("mcFwd")
        utils.debug_log("[MOVEMENT_BASE] on_key_release: flag reset check - should_keep_blocking=" .. tostring(should_keep_blocking) .. ", resetting flag=" .. tostring(not should_keep_blocking))

        if not should_keep_blocking then
            sprint_key_was_blocked = false
        end
    -- Movement release
    elseif (key == bind_to_dik(key_bindings.kFWD)) or (key == bind_to_dik(key_bindings.kBACK)) then
        state.moving = false
    end
end
