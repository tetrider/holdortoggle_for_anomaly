-- holdortoggle/movement_base.script
-- Basic movement (crouch, walk, sprint) when no stance system is active

local state = holdortoggle_state
local utils = holdortoggle_utils
local stance_utils = holdortoggle_stance_utils
local config = nil  -- Will be set by core

-- MCM options
local hot_crouch = 0 -- 0=Hold, 1=Toggle, 2=Hold+Toggle
local hot_walk = 0 -- 0=Hold, 1=Toggle, 2=Hold+Toggle
local hot_sprint = 0 -- 0=Hold, 1=Toggle, 2=Hold+Toggle
local hot_sprint_cancel = false

-- Track if last sprint press was blocked
local sprint_key_was_blocked = false

-- Track if restoration TimeEvent is currently active
local restoration_active = false

function set_config_module(cfg)
    config = cfg
end

function update_options()
    if ui_mcm then
        hot_crouch = ui_mcm.get("mcm/holdortoggle/main/hot_crouch")
        hot_walk = ui_mcm.get("mcm/holdortoggle/main/hot_walk")
        hot_sprint = ui_mcm.get("mcm/holdortoggle/main/hot_sprint")
        hot_sprint_cancel = ui_mcm.get("mcm/holdortoggle/qol/hot_sprint_cancel")
    end
end

-- OPTIMIZATION NOTES:
-- 1. Early exit: ~95% reduction in per-frame overhead (most frames do no work)
-- 2. Sprint restoration: Moved from per-frame polling to one-time TimeEvent
-- 3. IsMoveState caching: Reduced redundant engine calls
function actor_on_update()
    -- Sprint activation for autowalking only
    -- Forward key press handles normal movement
    if not ((hot_sprint == 0 or hot_sprint == 2) and
            (state.holding_sprint or state.sprint_key_down) and
            state.autowalking) then
        return
    end

    if (hot_sprint == 0 or hot_sprint == 2) and
       (state.holding_sprint or state.sprint_key_down) and
       state.autowalking then

        local is_sprinting = IsMoveState("mcSprint")
        local is_moving_fwd = IsMoveState("mcFwd")

        if not is_sprinting then
            local would_be_blocked = hot_sprint_cancel and not is_moving_fwd

            if hot_sprint == 0 and not would_be_blocked then
                state.allow_sprint_activation_from_forward = true
                level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                state.allow_sprint_activation_from_forward = false
                utils.debug_log("[MOVEMENT_BASE] actor_on_update: activating sprint (Hold mode, autowalking)")
            elseif not would_be_blocked and (sprint_key_was_blocked or (hot_sprint_cancel and not is_moving_fwd)) then
                state.allow_sprint_activation_from_forward = true
                level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                state.allow_sprint_activation_from_forward = false
                utils.debug_log("[MOVEMENT_BASE] actor_on_update: activating sprint (Hold+Toggle, autowalking)")
            end
        end
    end
end

-- Handle sprint blocking and state restoration when hot_sprint_cancel is enabled
-- Returns true if sprint was blocked, false otherwise
local function handle_sprint_blocking()
    if not hot_sprint_cancel then
        return false
    end

    local is_moving_fwd = IsMoveState("mcFwd")

    -- Allow if triggered by forward key press handler
    if state.allow_sprint_activation_from_forward then
        return false
    end

    -- Block if not moving forward
    if not is_moving_fwd then
        utils.debug_log("[MOVEMENT_BASE] on_before_key_press: blocking sprint (hot_sprint_cancel enabled, not moving forward)")
        sprint_key_was_blocked = true

        -- Capture current states for restoration
        -- Game engine auto-cancels crouch/walk even after our blocking
        local captured_crouch = IsMoveState("mcCrouch")
        local captured_walk = IsMoveState("mcAccel")

        utils.debug_log("[MOVEMENT_BASE] on_before_key_press: captured states - crouch=" .. tostring(captured_crouch) .. ", walk=" .. tostring(captured_walk))

        -- Create TimeEvent to restore states
        if captured_crouch or captured_walk then
            if restoration_active then
                utils.debug_log("[MOVEMENT_BASE] on_before_key_press: restoration already active, skipping new TimeEvent")

                -- Re-set flags if cleared by previous restoration
                if captured_crouch and not state.restoring_crouch_from_sprint_block then
                    state.restoring_crouch_from_sprint_block = true
                    utils.debug_log("[SPRINT DEBUG] Re-set restoring_crouch flag (restoration overlap)")
                end
                if captured_walk and not state.restoring_walk_from_sprint_block then
                    state.restoring_walk_from_sprint_block = true
                    utils.debug_log("[SPRINT DEBUG] Re-set restoring_walk flag (restoration overlap)")
                end

                -- Remove pending flag clear timer
                RemoveTimeEvent("holdortoggle", "clear_restoration_flags")
                utils.debug_log("[SPRINT DEBUG] Removed pending flag clear timer (restoration active)")
            else
                restoration_active = true
                RemoveTimeEvent("holdortoggle", "clear_restoration_flags")

                -- Set flags immediately
                if captured_crouch then
                    state.restoring_crouch_from_sprint_block = true
                    utils.debug_log("[SPRINT DEBUG] Set restoring_crouch flag immediately")
                end
                if captured_walk then
                    state.restoring_walk_from_sprint_block = true
                    utils.debug_log("[SPRINT DEBUG] Set restoring_walk flag immediately")
                end

                local block_time = time_global()
                local repeat_count = 0
                local MAX_REPEATS = 10

                CreateTimeEvent("holdortoggle", "restore_sprint_block_states", 0, function()
                    repeat_count = repeat_count + 1

                    -- Safety check
                    if repeat_count > MAX_REPEATS then
                        utils.debug_log("[SPRINT DEBUG] Max repeats reached after " .. (time_global() - block_time) .. "ms, stopping")
                        restoration_active = false
                        state.restoring_crouch_from_sprint_block = false
                        state.restoring_walk_from_sprint_block = false
                        return true
                    end

                    -- Skip if started moving forward
                    if IsMoveState("mcFwd") then
                        utils.debug_log("[SPRINT DEBUG] Moving forward, skipping restoration")
                        restoration_active = false
                        state.restoring_crouch_from_sprint_block = false
                        state.restoring_walk_from_sprint_block = false
                        return true
                    end

                    local is_crouching = IsMoveState("mcCrouch")
                    local is_walking = IsMoveState("mcAccel")

                    -- Wait for engine to cancel states
                    if (captured_crouch and is_crouching) or (captured_walk and is_walking) then
                        utils.debug_log("[SPRINT DEBUG] States still active, waiting... (frame " .. repeat_count .. ")")
                        return false
                    end

                    -- Restore states (walk first, then crouch)
                    utils.debug_log("[SPRINT DEBUG] RESTORE after " .. (time_global() - block_time) .. "ms (" .. repeat_count .. " frames)")

                    if captured_walk and not is_walking then
                        utils.debug_log("[SPRINT DEBUG] RESTORING WALK")
                        level.press_action(bind_to_dik(key_bindings.kACCEL))
                    end

                    if captured_crouch and not is_crouching then
                        utils.debug_log("[SPRINT DEBUG] RESTORING CROUCH")
                        level.press_action(bind_to_dik(key_bindings.kCROUCH))
                    end

                    -- Keep flags for 0.1s
                    CreateTimeEvent("holdortoggle", "clear_restoration_flags", 0.1, function()
                        state.restoring_crouch_from_sprint_block = false
                        state.restoring_walk_from_sprint_block = false
                        utils.debug_log("[SPRINT DEBUG] Cleared restoration flags")
                        return true
                    end)

                    restoration_active = false
                    return true
                end)
            end
        end

        return true  -- Sprint was blocked
    end

    return false  -- Sprint not blocked
end

-- Activate sprint when forward is pressed while holding sprint
-- Uses retry mechanism to wait for forward key to be processed by engine
local function try_activate_sprint_on_forward()
    local attempt_count = 0
    local MAX_ATTEMPTS = 5  -- Try for up to 5 frames (~83ms at 60fps)

    CreateTimeEvent("holdortoggle", "activate_sprint_on_forward", 0, function()
        attempt_count = attempt_count + 1

        -- Stop if max attempts reached, sprint no longer held, or already sprinting
        if attempt_count >= MAX_ATTEMPTS or
           not (state.holding_sprint or state.sprint_key_down) or
           IsMoveState("mcSprint") then
            return true
        end

        -- Activate sprint once mcFwd is true
        if IsMoveState("mcFwd") then
            local ads_is_active = axr_main.weapon_is_zoomed

            if hot_sprint == 0 or sprint_key_was_blocked then
                -- Set flags for sprint activation and preservation (if ADS active)
                state.allow_sprint_activation_from_forward = true
                state.preserve_sprint_flags = ads_is_active

                level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                state.allow_sprint_activation_from_forward = false

                -- If ADS is active, press sprint again after canceling ADS
                if ads_is_active then
                    CreateTimeEvent("holdortoggle", "activate_sprint_after_ads_cancel", 0.05, function()
                        if (state.holding_sprint or state.sprint_key_down) and not IsMoveState("mcSprint") then
                            state.allow_sprint_activation_from_forward = true
                            state.preserve_sprint_flags = false
                            level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                            state.allow_sprint_activation_from_forward = false
                        end
                        return true
                    end)
                end
            end

            return true  -- Stop after activation
        else
            return false  -- Retry next frame
        end
    end)
end

function on_before_key_press(dik, bind, dis, flags)
    if bind == stance_utils.get_sprint_key() then
        -- For Hold mode (0): Set holding state immediately (actor_on_update controls activation)
        -- For Hold+Toggle mode (2): Set sprint_key_down to track press (holding_sprint set later in on_key_hold)
        if hot_sprint == 0 then
            state.holding_sprint = true
            utils.debug_log("[MOVEMENT_BASE] on_before_key_press: tracking sprint hold (Hold mode)")
        elseif hot_sprint == 2 then
            state.sprint_key_down = true
            utils.debug_log("[MOVEMENT_BASE] on_before_key_press: tracking sprint press (Hold+Toggle mode)")
        end

        -- Handle sprint blocking and state restoration
        if handle_sprint_blocking() then
            return true  -- Block sprint from reaching game
        end

        -- For Toggle and Hold+Toggle modes, let the key through normally
        -- Action canceling is handled in on_key_press based on hot_sprint_cancel
    end
end

function on_key_press(key)
    -- Sprint cancels lean, aim, and prone toggles
    if (key == bind_to_dik(stance_utils.get_sprint_key())) then
        -- Only cancel actions if hot_sprint_cancel is disabled OR player is moving forward
        if not hot_sprint_cancel or IsMoveState("mcFwd") then
            if not (state.holding_lean_left or state.holding_lean_right) then
                if IsMoveState("mcLLookout") then level.press_action(bind_to_dik(key_bindings.kL_LOOKOUT)) end
                if IsMoveState("mcRLookout") then level.press_action(bind_to_dik(key_bindings.kR_LOOKOUT)) end
            end

            -- Cancel aim/zoom only if aim toggle is ON (in hold mode, releasing aim cancels it anyway)
            if axr_main.weapon_is_zoomed then
                utils.debug_log("[MOVEMENT_BASE] on_key_press: weapon_is_zoomed=true, is_aiming_toggled=" .. tostring(state.is_aiming_toggled))
                if state.is_aiming_toggled then
                    level.press_action(bind_to_dik(key_bindings.kWPN_ZOOM))
                    utils.debug_log("[MOVEMENT_BASE] on_key_press: canceling aim (toggle mode)")
                else
                    utils.debug_log("[MOVEMENT_BASE] on_key_press: NOT canceling aim (hold mode)")
                end
            end
        end
    end

    -- Track crouch press for Hold mode (only if no stance system is handling it)
    if (key == bind_to_dik(key_bindings.kCROUCH)) then
        if not state.active_stance_system or not state.active_stance_system.is_handling_crouch() then
            -- For Hold mode (0), immediately mark as holding to mimic hold behavior
            if hot_crouch == 0 then
                state.holding_crouch = true
            end
        end
    end

    -- Track walk press for Hold mode (only if no stance system is handling it)
    if (key == bind_to_dik(key_bindings.kACCEL)) then
        if not state.active_stance_system or not state.active_stance_system.is_handling_walk() then
            -- For Hold mode (0), immediately mark as holding to mimic hold behavior
            if hot_walk == 0 then
                state.holding_walk = true
            end
        end
    end

    -- Sprint Hold mode (0) tracking is handled in on_before_key_press
    -- This allows tracking even when sprint is blocked by hot_sprint_cancel

    -- Dirty move check
    if (key == bind_to_dik(key_bindings.kFWD)) or (key == bind_to_dik(key_bindings.kBACK)) then
        state.moving = true

        -- Try to activate sprint on forward key press (if holding sprint)
        if key == bind_to_dik(key_bindings.kFWD) and
           (hot_sprint == 0 or hot_sprint == 2) and
           (state.holding_sprint or state.sprint_key_down) and
           not IsMoveState("mcSprint") then
            try_activate_sprint_on_forward()
        end
    end
end

function on_key_hold(key)
    local is_modifier = utils.is_modifier_key(key)

    -- Crouch hold (only if no stance system is handling it)
    -- For Hold+Toggle mode (2), track when key passes hold threshold
    if (key == bind_to_dik(key_bindings.kCROUCH)) and ui_mcm.key_hold("holdortoggle", key) and IsMoveState("mcCrouch") then
        if not state.active_stance_system or not state.active_stance_system.is_handling_crouch() then
            -- Only set holding for Hold+Toggle mode (2)
            -- Hold mode (0) already set it in on_key_press
            if hot_crouch == 2 then
                state.holding_crouch = true
            end
            if is_modifier then return end
        end
    -- Walk hold (only if no stance system is handling it)
    -- For Hold+Toggle mode (2), track when key passes hold threshold
    elseif (key == bind_to_dik(key_bindings.kACCEL)) and ui_mcm.key_hold("holdortoggle", key) and IsMoveState("mcAccel") then
        if not state.active_stance_system or not state.active_stance_system.is_handling_walk() then
            -- Only set holding for Hold+Toggle mode (2)
            -- Hold mode (0) already set it in on_key_press
            if hot_walk == 2 then
                state.holding_walk = true
            end
            if is_modifier then return end
        end
    -- Sprint hold
    -- For Hold+Toggle mode (2), track when key passes hold threshold
    elseif (key == bind_to_dik(stance_utils.get_sprint_key())) and ui_mcm.key_hold("holdortoggle", key) and IsMoveState("mcSprint") then
        -- For Hold+Toggle mode (2): Mark as holding after threshold (distinguishes hold from tap)
        -- Hold mode (0) already set it in on_before_key_press
        if hot_sprint == 2 then
            state.holding_sprint = true
            utils.debug_log("[MOVEMENT_BASE] on_key_hold: sprint held past threshold (Hold+Toggle mode)")
        end
        if is_modifier then return end
    end
end

function on_key_release(key)
    -- Crouch release (only if no stance system is handling it)
    if (key == bind_to_dik(key_bindings.kCROUCH)) and state.holding_crouch then
        if not state.active_stance_system or not state.active_stance_system.is_handling_crouch() then
            if IsMoveState("mcCrouch") then
                level.press_action(bind_to_dik(key_bindings.kCROUCH))
            end
            state.holding_crouch = false
            utils.holdfix()
        end
    -- Walk release (only if no stance system is handling it)
    elseif (key == bind_to_dik(key_bindings.kACCEL)) and state.holding_walk then
        if not state.active_stance_system or not state.active_stance_system.is_handling_walk() then
            if IsMoveState("mcAccel") then
                level.press_action(bind_to_dik(key_bindings.kACCEL))
            end
            state.holding_walk = false
            utils.holdfix()
        end
    -- Sprint release
    elseif (key == bind_to_dik(stance_utils.get_sprint_key())) then
        utils.debug_log("[MOVEMENT_BASE] on_key_release: sprint released - hot_sprint=" .. tostring(hot_sprint) .. ", holding_sprint=" .. tostring(state.holding_sprint) .. ", sprint_key_was_blocked=" .. tostring(sprint_key_was_blocked))

        if hot_sprint == 0 then
            -- Hold mode: always deactivate if sprinting
            if state.holding_sprint and IsMoveState("mcSprint") then
                level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                utils.debug_log("[MOVEMENT_BASE] on_key_release: deactivating sprint (Hold mode)")
            end
        elseif hot_sprint == 2 then
            -- Hold+Toggle mode:
            -- - If held (holding_sprint is true): always deactivate
            -- - If tapped (holding_sprint is false) while sprinting AND key was blocked: toggle off
            if state.holding_sprint then
                -- Was held past threshold, deactivate
                if IsMoveState("mcSprint") then
                    level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                    utils.debug_log("[MOVEMENT_BASE] on_key_release: deactivating sprint (held)")
                end
            elseif state.sprint_key_down and sprint_key_was_blocked and IsMoveState("mcSprint") then
                -- Was tapped while sprinting AND key was blocked (didn't reach game), manually toggle off
                level.press_action(bind_to_dik(stance_utils.get_sprint_key()))
                utils.debug_log("[MOVEMENT_BASE] on_key_release: toggling sprint off (tapped, was blocked)")
            end
            -- else: tapped and key wasn't blocked, game already handled toggle
        end
        -- Preserve sprint flags if ADS re-activation is pending
        if not state.preserve_sprint_flags then
            state.holding_sprint = false
            state.sprint_key_down = false
        else
            state.preserve_sprint_flags = false
        end

        -- Only call holdfix if sprint wasn't blocked (optional optimization)
        if not sprint_key_was_blocked then
            utils.holdfix()
        end

        -- Only reset blocked flag if blocking condition is no longer true
        -- This prevents creating multiple TimeEvents when rapidly tapping sprint while stationary
        local should_keep_blocking = hot_sprint_cancel and not IsMoveState("mcFwd")
        utils.debug_log("[MOVEMENT_BASE] on_key_release: flag reset check - should_keep_blocking=" .. tostring(should_keep_blocking) .. ", resetting flag=" .. tostring(not should_keep_blocking))

        if not should_keep_blocking then
            sprint_key_was_blocked = false
        end
    -- Movement release
    elseif (key == bind_to_dik(key_bindings.kFWD)) or (key == bind_to_dik(key_bindings.kBACK)) then
        state.moving = false
    end
end
