-- holdortoggle/stance_systems/fluid_stance.script
-- Fluid stance system (prone_keybind_only = true)
-- Advanced system: crouch ↔ walk ↔ prone fluid transitions with time-based toggle prevention

local state = holdortoggle_state
local utils = holdortoggle_utils
local stance_utils = holdortoggle_stance_utils

-- Stance system state
local prone_active = false
local holding_prone_key = false
local manually_exited_prone = false
local exiting_prone_via_crouch = false
local exiting_prone_via_walk = false
local prone_exit_time = 0
local toggling_prone_programmatically = false
local prone_activated_by_this_press = false  -- Track if prone was activated by current prone key press
local walk_held_while_exiting = false  -- Track if walk key was held while exiting prone (for Hold+Toggle mode)
local crouch_held_while_exiting = false  -- Track if crouch key was held while exiting prone (for Hold+Toggle mode)
local prone_toggle_frame_count = 0  -- Frame counter for prone toggle flag persistence

-- Keybind and mode
local pronekey = DIK_keys.DIK_Z
local pronekey_mode = 0  -- 0=Disabled, 1=Hold, 2=Toggle, 3=Hold+Toggle
local walk_mode = 1  -- 0=Hold, 1=Toggle, 2=Hold+Toggle (default to Toggle)
local crouch_mode = 1  -- 0=Hold, 1=Toggle, 2=Hold+Toggle (default to Toggle)

-- Interface implementation
function initialize()
    utils.debug_log("[FLUID_STANCE] Initialized")
end

function shutdown()
    utils.debug_log("[FLUID_STANCE] Shutdown")
    prone_active = false
    holding_prone_key = false
    manually_exited_prone = false
    exiting_prone_via_crouch = false
    exiting_prone_via_walk = false
    prone_exit_time = 0
    prone_activated_by_this_press = false
    walk_held_while_exiting = false
    crouch_held_while_exiting = false
    -- Cancel any pending TimeEvents
    RemoveTimeEvent("ensure_crouch_after_prone", "restore_stance")
    RemoveTimeEvent("ensure_walk_after_prone", "restore_stance")
end

function is_stance_active()
    return prone_active
end

function is_handling_crouch()
    return true  -- Fluid stance always handles crouch
end

function is_handling_walk()
    return true  -- Fluid stance always handles walk
end

function set_pronekey(key)
    pronekey = key
end

function set_pronekey_mode(mode)
    pronekey_mode = mode
    utils.debug_log("[FLUID_STANCE] Prone key mode set to: " .. tostring(mode))
end

function set_walk_mode(mode)
    walk_mode = mode
    utils.debug_log("[FLUID_STANCE] Walk mode set to: " .. tostring(mode))
end

function set_crouch_mode(mode)
    crouch_mode = mode
    utils.debug_log("[FLUID_STANCE] Crouch mode set to: " .. tostring(mode))
end

-- Generic prone exit handler - eliminates duplication between crouch/walk exit paths
-- Returns: boolean indicating if manually_exited_prone flag should be set
local function deactivate_prone_via_stance(config)
    utils.debug_log(config.system_name .. " " .. config.stance_name .. " pressed while prone - deactivating prone, mcCrouch=" .. tostring(IsMoveState("mcCrouch")) .. ", mcAccel=" .. tostring(IsMoveState("mcAccel")))

    -- Update exit time for protection window
    prone_exit_time = time_global()

    -- Cancel ALL prone exit TimeEvents (both crouch and walk)
    RemoveTimeEvent("ensure_crouch_after_prone", "restore_stance")
    RemoveTimeEvent("ensure_walk_after_prone", "restore_stance")

    -- Force holding state to prevent toggle-off on release
    state[config.holding_state_key] = true

    -- Check if manual exit (captured before stance change)
    -- Note: holding_prone_var is passed as a boolean VALUE, not a reference
    local should_set_manual_exit = config.holding_prone_var

    -- Set programmatic flags to prevent recursion and coordinate with sprint blocking
    toggling_prone_programmatically = true
    state.prone_restoration_active = true

    -- Turn off opposite stance (keep target stance active)
    if IsMoveState(config.move_state_remove) then
        level.press_action(bind_to_dik(config.key_binding_remove))
    end

    -- Create restoration TimeEvent to ensure target stance stays active
    -- Wait for engine to process prone toggle, then restore once if needed
    local check_count = 0
    local restored = false
    local MAX_FRAMES = 10  -- Safety limit

    CreateTimeEvent(config.timeevent_prefix, "restore_stance", 0, function()
        check_count = check_count + 1

        -- Safety check - stop after max frames
        if check_count > MAX_FRAMES then
            utils.debug_log(config.system_name .. " Restoration timeout after " .. MAX_FRAMES .. " frames")
            toggling_prone_programmatically = false
            state.prone_restoration_active = false
            -- Clear prone restoration flags we may have set
            if config.key_binding_keep == key_bindings.kCROUCH then
                state.restoring_crouch_from_prone_exit = false
            elseif config.key_binding_keep == key_bindings.kACCEL then
                state.restoring_walk_from_prone_exit = false
            end
            return true
        end

        -- Wait 2-3 frames for prone animation to process
        if check_count <= 3 then
            return false  -- Keep waiting
        end

        -- Skip restoration if sprint blocking restoration is already handling it
        if (config.key_binding_keep == key_bindings.kCROUCH and state.restoring_crouch_from_sprint_block) or
           (config.key_binding_keep == key_bindings.kACCEL and state.restoring_walk_from_sprint_block) then
            utils.debug_log(config.system_name .. " Sprint blocking restoration active, skipping prone restoration")
            toggling_prone_programmatically = false
            state.prone_restoration_active = false
            return true
        end

        -- After waiting, restore once if stance is off (only if not already restored)
        if not restored and not IsMoveState(config.move_state_keep) then
            utils.debug_log(config.system_name .. " " .. config.stance_name .. " off after prone exit, restoring once")
            -- CRITICAL: Set prone restoration flags IMMEDIATELY before press to prevent recursion
            if config.key_binding_keep == key_bindings.kCROUCH then
                state.restoring_crouch_from_prone_exit = true
                utils.debug_log("[RECURSION GUARD] Set prone restoring_crouch flag before press")
            elseif config.key_binding_keep == key_bindings.kACCEL then
                state.restoring_walk_from_prone_exit = true
                utils.debug_log("[RECURSION GUARD] Set prone restoring_walk flag before press")
            end
            level.press_action(bind_to_dik(config.key_binding_keep))
            restored = true
            return false  -- Wait one more frame to verify
        end

        -- Done - either stance is already active or we've restored it
        toggling_prone_programmatically = false
        state.prone_restoration_active = false
        -- Clear prone restoration flags we set for recursion protection
        if config.key_binding_keep == key_bindings.kCROUCH then
            state.restoring_crouch_from_prone_exit = false
        elseif config.key_binding_keep == key_bindings.kACCEL then
            state.restoring_walk_from_prone_exit = false
        end
        utils.debug_log(config.system_name .. " Restoration complete, flags cleared")
        return true
    end)

    utils.debug_log(config.system_name .. " " .. config.stance_name .. " exit complete, " .. config.move_state_keep .. "=" .. tostring(IsMoveState(config.move_state_keep)) .. ", " .. config.holding_state_key .. "=" .. tostring(state[config.holding_state_key]))

    return should_set_manual_exit
end

-- Deactivate prone via crouch key
local function deactivate_prone_via_crouch()
    -- Set stance-specific flags
    prone_active = false
    exiting_prone_via_crouch = true
    crouch_held_while_exiting = false  -- Reset, will be set by on_key_hold if user holds

    -- Call generic helper with crouch-specific config
    local should_set_manual_exit = deactivate_prone_via_stance({
        stance_name = "Crouch",
        system_name = "[FLUID_STANCE]",
        holding_state_key = "holding_crouch",
        holding_prone_var = holding_prone_key,
        move_state_keep = "mcCrouch",
        move_state_remove = "mcAccel",
        key_binding_keep = key_bindings.kCROUCH,
        key_binding_remove = key_bindings.kACCEL,
        timeevent_prefix = "ensure_crouch_after_prone"
    })

    -- Set manual exit flag if needed
    if should_set_manual_exit then
        manually_exited_prone = true
    end
end

-- Deactivate prone via walk key
local function deactivate_prone_via_walk()
    -- Set stance-specific flags
    prone_active = false
    exiting_prone_via_walk = true
    walk_held_while_exiting = false  -- Reset, will be set by on_key_hold if user holds

    -- Call generic helper with walk-specific config
    local should_set_manual_exit = deactivate_prone_via_stance({
        stance_name = "Walk",
        system_name = "[FLUID_STANCE]",
        holding_state_key = "holding_walk",
        holding_prone_var = holding_prone_key,
        move_state_keep = "mcAccel",
        move_state_remove = "mcCrouch",
        key_binding_keep = key_bindings.kACCEL,
        key_binding_remove = key_bindings.kCROUCH,
        timeevent_prefix = "ensure_walk_after_prone"
    })

    -- Set manual exit flag if needed
    if should_set_manual_exit then
        manually_exited_prone = true
    end
end

function on_key_press(key)
    -- Don't process any stance keys if we're programmatically toggling prone
    if toggling_prone_programmatically then
        if (key == bind_to_dik(key_bindings.kCROUCH)) or
           (key == bind_to_dik(key_bindings.kACCEL)) or
           (key == pronekey) or
           (key == bind_to_dik(stance_utils.get_sprint_key())) then
            return true  -- Block all stance keys during prone toggle
        end
    end

    -- Crouch key pressed
    if (key == bind_to_dik(key_bindings.kCROUCH)) then
        -- If this is a programmatic restore, skip fluid stance logic
        -- Game engine will still toggle crouch state regardless of return value
        if state.restoring_crouch_from_sprint_block or state.restoring_crouch_from_prone_exit then
            utils.debug_log("[FLUID_STANCE] Skipping programmatic crouch restore")
            return true  -- Block other handlers, but game engine still processes the key
        end

        -- Deactivate prone if active
        if prone_active then
            deactivate_prone_via_crouch()
            -- Return early - don't let the crouch key press continue
            return true
        end

        -- If walk is active, switch to crouch (skip if this is programmatic cancellation to avoid recursion)
        if not state.canceling_crouch and IsMoveState("mcAccel") then
            state.canceling_walk = true
            utils.debug_log("[FLUID_STANCE] Canceling walk (crouch pressed)")
            level.press_action(bind_to_dik(key_bindings.kACCEL))
        elseif state.canceling_crouch then
            utils.debug_log("[FLUID_STANCE] Skipping opposite stance cancellation (programmatic crouch cancellation)")
            state.canceling_crouch = false
        end
        -- Let crouch key press continue normally
        return false
    end

    -- Walk key pressed
    if (key == bind_to_dik(key_bindings.kACCEL)) then
        -- If this is a programmatic restore, skip fluid stance logic
        -- Game engine will still toggle walk state regardless of return value
        if state.restoring_walk_from_sprint_block or state.restoring_walk_from_prone_exit then
            utils.debug_log("[FLUID_STANCE] Skipping programmatic walk restore")
            return true  -- Block other handlers, but game engine still processes the key
        end

        -- Deactivate prone if active
        if prone_active then
            deactivate_prone_via_walk()
            -- Return early - don't let the walk key press continue
            return true
        end

        -- If crouch is active, switch to walk (skip if this is programmatic cancellation to avoid recursion)
        if not state.canceling_walk and IsMoveState("mcCrouch") then
            state.canceling_crouch = true
            utils.debug_log("[FLUID_STANCE] Canceling crouch (walk pressed)")
            level.press_action(bind_to_dik(key_bindings.kCROUCH))
        elseif state.canceling_walk then
            utils.debug_log("[FLUID_STANCE] Skipping opposite stance cancellation (programmatic walk cancellation)")
            state.canceling_walk = false
        end
        -- Let walk key press continue normally
        return false
    end

    -- Sprint cancels prone
    if (key == bind_to_dik(stance_utils.get_sprint_key())) and prone_active then
        if stance_utils.should_cancel_prone_for_sprint() then
            utils.debug_log("[FLUID_STANCE] Sprint pressed while prone - canceling prone")
            toggle_prone()
        else
            utils.debug_log("[FLUID_STANCE] Sprint pressed while prone but not moving forward - ignoring (hot_sprint_cancel enabled)")
        end
        return false  -- Let movement_base handle sprint
    end

    -- Prone key press (only if prone key mode is enabled)
    if (key == pronekey) and pronekey_mode > 0 then
        utils.debug_log("[FLUID_STANCE] Prone key pressed (mode=" .. tostring(pronekey_mode) .. "), prone_active=" .. tostring(prone_active) .. ", manually_exited_prone=" .. tostring(manually_exited_prone))
        -- Don't toggle if we just manually exited prone or if we're currently exiting
        if not manually_exited_prone and not exiting_prone_via_crouch and not exiting_prone_via_walk then
            if pronekey_mode == 1 then
                -- Hold mode: Only activate prone if not already prone
                holding_prone_key = true
                if not prone_active then
                    toggle_prone()
                    utils.debug_log("[FLUID_STANCE] Hold mode - entering prone")
                else
                    utils.debug_log("[FLUID_STANCE] Hold mode - already prone, holding to stay prone")
                end
            elseif pronekey_mode == 2 then
                -- Toggle mode: Always toggle on press
                toggle_prone()
            elseif pronekey_mode == 3 then
                -- Hold+Toggle mode: Only toggle if not already prone
                if not prone_active then
                    toggle_prone()
                    prone_activated_by_this_press = true
                    utils.debug_log("[FLUID_STANCE] Hold+Toggle mode - entering prone")
                else
                    prone_activated_by_this_press = false
                    utils.debug_log("[FLUID_STANCE] Hold+Toggle mode - already prone, waiting for hold/tap decision")
                end
            end
        else
            utils.debug_log("[FLUID_STANCE] Skipping prone toggle - just manually exited or currently exiting")
            manually_exited_prone = false
        end
        return true
    end

    return false
end

function on_key_hold(key)
    -- Crouch hold (respects crouch mode setting)
    if (key == bind_to_dik(key_bindings.kCROUCH)) and ui_mcm.key_hold("holdortoggle", key) and IsMoveState("mcCrouch") then
        if exiting_prone_via_crouch then
            -- Track that crouch was held while exiting prone (for Hold+Toggle mode)
            crouch_held_while_exiting = true
            utils.debug_log("[FLUID_STANCE] Crouch held while exiting prone (crouch_mode=" .. tostring(crouch_mode) .. ")")
            return true
        else
            -- Normal crouch hold behavior - respect crouch mode
            if crouch_mode == 0 then
                -- Hold mode: always track holding
                state.holding_crouch = true
            elseif crouch_mode == 2 then
                -- Normal Hold+Toggle mode behavior (not exiting prone)
                state.holding_crouch = true
            end
            if utils.is_modifier_key(key) then return true end
            return true
        end
    -- Walk hold (respects walk mode setting)
    elseif (key == bind_to_dik(key_bindings.kACCEL)) and ui_mcm.key_hold("holdortoggle", key) and IsMoveState("mcAccel") then
        if exiting_prone_via_walk then
            -- Track that walk was held while exiting prone (for Hold+Toggle mode)
            walk_held_while_exiting = true
            utils.debug_log("[FLUID_STANCE] Walk held while exiting prone (walk_mode=" .. tostring(walk_mode) .. ")")
            return true
        else
            -- Normal walk hold behavior - respect walk mode
            if walk_mode == 0 then
                -- Hold mode: always track holding
                state.holding_walk = true
            elseif walk_mode == 2 then
                -- Normal Hold+Toggle mode behavior (not exiting prone)
                state.holding_walk = true
            end
            if utils.is_modifier_key(key) then return true end
            return true
        end
    -- Prone key hold (only if prone key mode is enabled)
    elseif (key == pronekey) and pronekey_mode > 0 and ui_mcm.key_hold("holdortoggle", key) and prone_active then
        -- Mode 1 (Hold): Already set holding on press
        -- Mode 2 (Toggle): Don't set holding flag (pure toggle, no hold behavior)
        -- Mode 3 (Hold+Toggle): Set holding flag to indicate it was held
        if pronekey_mode == 3 then
            holding_prone_key = true
            utils.debug_log("[FLUID_STANCE] Prone key held (Hold+Toggle mode) - will toggle off on release")
        end
        return true
    end

    return false
end

function on_key_release(key)
    -- Crouch release
    if (key == bind_to_dik(key_bindings.kCROUCH)) and state.holding_crouch then
        local time_since_exit = prone_exit_time and (time_global() - prone_exit_time) or 999999
        utils.debug_log("[FLUID_STANCE] Crouch released, exiting_prone_via_crouch=" .. tostring(exiting_prone_via_crouch) .. ", crouch_held_while_exiting=" .. tostring(crouch_held_while_exiting) .. ", prone_active=" .. tostring(prone_active) .. ", mcCrouch=" .. tostring(IsMoveState("mcCrouch")) .. ", time_since_exit=" .. tostring(time_since_exit) .. ", crouch_mode=" .. tostring(crouch_mode))

        -- Mode 0 (Hold): Always toggle off on release
        -- Mode 1 (Toggle): Never toggle off on release (unless exiting prone)
        -- Mode 2 (Hold+Toggle): Toggle off if held, keep if tapped

        if exiting_prone_via_crouch then
            -- Special case: exiting prone via crouch
            -- Mode 2 (Hold+Toggle): Only toggle off if crouch was held while exiting
            if crouch_mode == 2 then
                if crouch_held_while_exiting and IsMoveState("mcCrouch") then
                    utils.debug_log("[FLUID_STANCE] Crouch mode 2 (Hold+Toggle): held while exiting, toggling off")
                    level.press_action(bind_to_dik(key_bindings.kCROUCH))
                else
                    utils.debug_log("[FLUID_STANCE] Crouch mode 2 (Hold+Toggle): tapped while exiting, keeping crouch")
                end
            -- Mode 0 (Hold): Always toggle off
            elseif crouch_mode == 0 then
                if IsMoveState("mcCrouch") then
                    utils.debug_log("[FLUID_STANCE] Crouch mode 0 (Hold): toggling off on release")
                    level.press_action(bind_to_dik(key_bindings.kCROUCH))
                end
            -- Mode 1 (Toggle): Keep crouch active (no toggle off)
            else
                utils.debug_log("[FLUID_STANCE] Crouch mode 1 (Toggle): keeping crouch active")
            end
        else
            -- Normal crouch release (not exiting prone)
            -- Don't toggle off if: exiting prone via crouch (within 200ms), OR prone is still active
            if not (exiting_prone_via_crouch and time_since_exit < 200) and not prone_active and IsMoveState("mcCrouch") then
                -- Mode 0 (Hold) or Mode 2 (Hold+Toggle): Toggle off
                if crouch_mode == 0 or crouch_mode == 2 then
                    utils.debug_log("[FLUID_STANCE] Crouch mode " .. tostring(crouch_mode) .. ": toggling off on release")
                    level.press_action(bind_to_dik(key_bindings.kCROUCH))
                else
                    utils.debug_log("[FLUID_STANCE] Crouch mode 1 (Toggle): keeping crouch active")
                end
            end
        end

        state.holding_crouch = false
        exiting_prone_via_crouch = false
        crouch_held_while_exiting = false
        utils.holdfix()
        return true
    elseif (key == bind_to_dik(key_bindings.kCROUCH)) and exiting_prone_via_crouch then
        -- Check if prone is still active
        if prone_active then
            -- Still prone, don't toggle
            utils.debug_log("[FLUID_STANCE] Quick crouch release after exiting prone - not toggling (prone still active)")
        else
            -- Prone was deactivated, allow normal toggle based on mode
            utils.debug_log("[FLUID_STANCE] Crouch release after exiting prone - prone is off, crouch_mode=" .. tostring(crouch_mode))
            -- Only toggle off for Hold mode (0), not for Toggle (1) or Hold+Toggle (2)
            if crouch_mode == 0 and IsMoveState("mcCrouch") then
                utils.debug_log("[FLUID_STANCE] Crouch mode 0 (Hold): toggling off")
                level.press_action(bind_to_dik(key_bindings.kCROUCH))
            end
        end
        exiting_prone_via_crouch = false
        crouch_held_while_exiting = false
        return true
    end

    -- Walk release
    if (key == bind_to_dik(key_bindings.kACCEL)) and state.holding_walk then
        local time_since_exit = prone_exit_time and (time_global() - prone_exit_time) or 999999
        utils.debug_log("[FLUID_STANCE] Walk released, exiting_prone_via_walk=" .. tostring(exiting_prone_via_walk) .. ", walk_held_while_exiting=" .. tostring(walk_held_while_exiting) .. ", prone_active=" .. tostring(prone_active) .. ", mcAccel=" .. tostring(IsMoveState("mcAccel")) .. ", time_since_exit=" .. tostring(time_since_exit) .. ", walk_mode=" .. tostring(walk_mode))

        -- Mode 0 (Hold): Always toggle off on release
        -- Mode 1 (Toggle): Never toggle off on release (unless exiting prone)
        -- Mode 2 (Hold+Toggle): Toggle off if held, keep if tapped

        if exiting_prone_via_walk then
            -- Special case: exiting prone via walk
            -- Mode 2 (Hold+Toggle): Only toggle off if walk was held while exiting
            if walk_mode == 2 then
                if walk_held_while_exiting and IsMoveState("mcAccel") then
                    utils.debug_log("[FLUID_STANCE] Walk mode 2 (Hold+Toggle): held while exiting, toggling off")
                    level.press_action(bind_to_dik(key_bindings.kACCEL))
                else
                    utils.debug_log("[FLUID_STANCE] Walk mode 2 (Hold+Toggle): tapped while exiting, keeping walk")
                end
            -- Mode 0 (Hold): Always toggle off
            elseif walk_mode == 0 then
                if IsMoveState("mcAccel") then
                    utils.debug_log("[FLUID_STANCE] Walk mode 0 (Hold): toggling off on release")
                    level.press_action(bind_to_dik(key_bindings.kACCEL))
                end
            -- Mode 1 (Toggle): Keep walk active (no toggle off)
            else
                utils.debug_log("[FLUID_STANCE] Walk mode 1 (Toggle): keeping walk active")
            end
        else
            -- Normal walk release (not exiting prone)
            -- Don't toggle off if: exiting prone via walk (within 200ms), OR prone is still active
            if not (exiting_prone_via_walk and time_since_exit < 200) and not prone_active and IsMoveState("mcAccel") then
                -- Mode 0 (Hold) or Mode 2 (Hold+Toggle): Toggle off
                if walk_mode == 0 or walk_mode == 2 then
                    utils.debug_log("[FLUID_STANCE] Walk mode " .. tostring(walk_mode) .. ": toggling off on release")
                    level.press_action(bind_to_dik(key_bindings.kACCEL))
                else
                    utils.debug_log("[FLUID_STANCE] Walk mode 1 (Toggle): keeping walk active")
                end
            end
        end

        state.holding_walk = false
        exiting_prone_via_walk = false
        walk_held_while_exiting = false
        utils.holdfix()
        return true
    elseif (key == bind_to_dik(key_bindings.kACCEL)) and exiting_prone_via_walk then
        -- Check if prone is still active
        if prone_active then
            -- Still prone, don't toggle
            utils.debug_log("[FLUID_STANCE] Quick walk release after exiting prone - not toggling (prone still active)")
        else
            -- Prone was deactivated, allow normal toggle based on mode
            utils.debug_log("[FLUID_STANCE] Walk release after exiting prone - prone is off, walk_mode=" .. tostring(walk_mode))
            -- Only toggle off for Hold mode (0), not for Toggle (1) or Hold+Toggle (2)
            if walk_mode == 0 and IsMoveState("mcAccel") then
                utils.debug_log("[FLUID_STANCE] Walk mode 0 (Hold): toggling off")
                level.press_action(bind_to_dik(key_bindings.kACCEL))
            end
        end
        exiting_prone_via_walk = false
        walk_held_while_exiting = false
        return true
    end

    -- Prone key release (only if prone key mode is enabled)
    if (key == pronekey) and pronekey_mode > 0 then
        if pronekey_mode == 1 then
            -- Hold mode: Toggle off on release if holding and prone
            if holding_prone_key and prone_active and not manually_exited_prone then
                toggle_prone()
                utils.debug_log("[FLUID_STANCE] Hold mode - standing up on release")
            end
            holding_prone_key = false
            manually_exited_prone = false
            utils.holdfix()
            return true
        elseif pronekey_mode == 2 then
            -- Toggle mode: Just clear flags, keep prone state
            utils.debug_log("[FLUID_STANCE] Toggle mode - keeping prone state")
            manually_exited_prone = false
            utils.holdfix()
            return true
        elseif pronekey_mode == 3 then
            -- Hold+Toggle mode: Behavior depends on hold status and whether prone was activated by this press
            if holding_prone_key then
                -- Was held
                if prone_active and not manually_exited_prone then
                    -- Held -> stand up on release (both cases: entered prone via this press OR was already prone)
                    toggle_prone()
                    if prone_activated_by_this_press then
                        utils.debug_log("[FLUID_STANCE] Hold+Toggle mode (held) - entered prone then held, standing up (temporary)")
                    else
                        utils.debug_log("[FLUID_STANCE] Hold+Toggle mode (held) - was already prone, standing up")
                    end
                end
            else
                -- Was tapped (not held)
                if not prone_activated_by_this_press and prone_active and not manually_exited_prone then
                    -- Was already prone before press, tapped -> stand up
                    toggle_prone()
                    utils.debug_log("[FLUID_STANCE] Hold+Toggle mode (tapped) - was already prone, standing up")
                else
                    -- Entered prone via this press, tapped -> stay prone (permanent toggle)
                    utils.debug_log("[FLUID_STANCE] Hold+Toggle mode (tapped) - entered prone, staying prone (permanent)")
                end
            end
            holding_prone_key = false
            prone_activated_by_this_press = false
            manually_exited_prone = false
            utils.holdfix()
            return true
        end
    end

    return false
end

function toggle_prone()
    -- Set flag to prevent crouch/walk handlers from interfering
    toggling_prone_programmatically = true

    local should_cleanup
    prone_active, should_cleanup = stance_utils.toggle_prone_state(prone_active, "[FLUID_STANCE]")

    if should_cleanup then
        toggling_prone_programmatically = false
        return
    end

    -- Keep flag set for a few frames to prevent immediate re-toggling
    -- This prevents held crouch/walk keys from immediately exiting prone
    -- Remove any existing event first to prevent duplicates
    RemoveTimeEvent("holdortoggle_prone_toggle", "clear_prone_flag")
    prone_toggle_frame_count = 0
    CreateTimeEvent("holdortoggle_prone_toggle", "clear_prone_flag", 0, function()
        prone_toggle_frame_count = prone_toggle_frame_count + 1
        if prone_toggle_frame_count >= 5 then
            toggling_prone_programmatically = false
            return true  -- Stop event
        end
        return false  -- Keep event running
    end)
end
