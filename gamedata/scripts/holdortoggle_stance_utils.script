-- holdortoggle/stance_utils.script
-- Shared utility functions for stance systems
-- Eliminates duplication across vanilla_prone, simple_prone, fluid_stance, progressive_stance

local utils = holdortoggle_utils
local state = holdortoggle_state

-- Helper function to get the correct sprint key binding based on toggle setting
function get_sprint_key()
    return state.is_sprint_toggled and key_bindings.kSPRINT_TOGGLE or key_bindings.kSPRINT
end

-- Generic prone toggle state logic
-- Returns: new_prone_active, should_cleanup
-- Parameters:
--   current_prone_active: boolean - current prone state
--   system_name: string - name for logging (e.g., "[VANILLA_PRONE]", "[FLUID_STANCE]")
-- Note: This function assumes crouch/walk are in Toggle or Hold+Toggle mode (game toggles ON)
function toggle_prone_state(current_prone_active, system_name)
    local was_active = current_prone_active
    local new_prone_active = not current_prone_active

    utils.debug_log(system_name .. " toggle_prone called: was_active=" .. tostring(was_active) .. ", now prone_active=" .. tostring(new_prone_active))

    -- Safety check - ensure actor exists
    if not db.actor then
        utils.debug_log("! " .. system_name .. " ERROR] Actor not found, aborting toggle")
        return current_prone_active, true  -- No change, signal cleanup needed
    end

    if new_prone_active then
        -- Activate prone: enable crouch and walk
        -- Using press_action works because game toggles are ON (enforced by config)
        if not IsMoveState("mcCrouch") then
            level.press_action(bind_to_dik(key_bindings.kCROUCH))
        end
        if not IsMoveState("mcAccel") then
            level.press_action(bind_to_dik(key_bindings.kACCEL))
        end
    else
        -- Deactivate prone: disable crouch and walk
        if IsMoveState("mcCrouch") then
            level.press_action(bind_to_dik(key_bindings.kCROUCH))
        end
        if IsMoveState("mcAccel") then
            level.press_action(bind_to_dik(key_bindings.kACCEL))
        end
    end

    -- Notify stance vignette of stance change
    if holdortoggle_features_stance_vignette then
        holdortoggle_features_stance_vignette.on_stance_change()
    end

    return new_prone_active, false
end

-- Check if prone should be canceled for sprint
-- Returns: boolean - true if prone should be canceled, false otherwise
function should_cancel_prone_for_sprint()
    local hot_sprint_cancel = ui_mcm and ui_mcm.get("mcm/holdortoggle/qol/hot_sprint_cancel") or false
    local is_moving_forward = IsMoveState("mcFwd")
    local should_cancel = not hot_sprint_cancel or is_moving_forward

    utils.debug_log("[STANCE_UTILS] should_cancel_prone_for_sprint: hot_sprint_cancel=" .. tostring(hot_sprint_cancel) .. ", is_moving_forward=" .. tostring(is_moving_forward) .. ", should_cancel=" .. tostring(should_cancel))

    return should_cancel
end

-- Multi-frame same-frame prone detection (used by TimeEvent as backup)
-- Recursively checks for up to 3 frames if both crouch and walk are active
-- Parameters:
--   system_name: string - name for logging (e.g., "[PROGRESSIVE_STANCE]")
--   stance_to_cancel: string - "crouch" or "walk" - which stance to cancel if both active
--   prone_active: boolean - current prone state (don't trigger if already prone)
--   event_namespace: string - TimeEvent namespace (e.g., "progressive_stance_prevent_prone")
--   event_id: string - TimeEvent ID (e.g., "fix_same_frame_crouch")
--   frame_count: number - current frame number (1-3)
--   verbose_logging: boolean - if true, log movement states each frame
-- Returns: true when done checking
function check_same_frame_prone(system_name, stance_to_cancel, prone_active, event_namespace, event_id, frame_count, verbose_logging)
    -- Verbose logging (Progressive Stance uses this)
    if verbose_logging then
        utils.debug_log(system_name .. " Same-frame check (frame " .. tostring(frame_count) .. "): mcCrouch=" .. tostring(IsMoveState("mcCrouch")) .. ", mcAccel=" .. tostring(IsMoveState("mcAccel")) .. ", prone_active=" .. tostring(prone_active))
    end

    -- Check if both crouch and walk are active (and not already prone)
    if IsMoveState("mcCrouch") and IsMoveState("mcAccel") and not prone_active then
        local log_suffix = verbose_logging and "" or ", frame " .. tostring(frame_count) .. ")"
        utils.debug_log(system_name .. " Same-frame prone detected (" .. (stance_to_cancel == "walk" and "crouch" or "walk") .. log_suffix .. " - canceling " .. stance_to_cancel)

        state.fixing_same_frame_prone = true
        if stance_to_cancel == "walk" then
            state.canceling_walk = true
            level.press_action(bind_to_dik(key_bindings.kACCEL))
        else  -- cancel crouch
            state.canceling_crouch = true
            level.press_action(bind_to_dik(key_bindings.kCROUCH))
        end
        state.fixing_same_frame_prone = false

        return true  -- Done, stop checking
    elseif frame_count < 3 then
        -- Check again on next frame
        CreateTimeEvent(event_namespace, event_id, 0.001, function()
            return check_same_frame_prone(system_name, stance_to_cancel, prone_active, event_namespace, event_id, frame_count + 1, verbose_logging)
        end)
    end

    return true  -- Stop checking
end
